lincomb.derived.only=FALSE),
#control.family = famcontrol,
control.fixed = list(expand.factor.strategy = "inla"),
data=model_list_of_lists[[i]][[j]]$.args$data,lincomb = lc,
control.update = list(result = model_list_of_lists[[i]][[j]]),
control.predictor=list(compute=TRUE),verbose=F)
lcd = newmodel$summary.lincomb
lcd$id = rownames(lcd)
lcd$group = str_extract(lcd$id,'^[u-y]')
lcd$group = ifelse(lcd$group== 'u','Project count','CE/total NEPA analyses')
lcd$group <- fct_rev(as.factor(lcd$group))
qvals = rbind(lcomb_data[,1:2],lcomb_data[,3:4],use.names = F)
names(qvals) <- c('scale_val1','scale_val2')
lcd$x1_quantile = unlist(replicate(2,rep(x1seq,nrow(lcd)/2/length(x1seq)),simplify = F))
lcd$x2_quantile = unlist(replicate(2,rep(x2seq,each = nrow(lcd)/2/length(x2seq)),simplify = F))
lcd = cbind(lcd,qvals)
axnames = unique(str_remove(names(temp_vars),'^[u-y]_'))
lcd[[axnames[[1]]]]<-lcomb_data[[names(temp_vars)[1]]]
lcd[[axnames[[2]]]]<-lcomb_data[[names(temp_vars)[2]]]
intername = gsub(':','x',str_remove_all(iname[[1]],'u_'))
figname = paste(mod_names[i],intername,sep='_')
lcd = data.table(lcd)
#lcd = lcd[!duplicated(paste(scale_val1,scale_val2,group)),]
lcd$i = i
lcd$j = j
lcd$DV <- mod_names[i]
empty_list = rbind(empty_list,lcd,fill = T,use.names = T)
}
}
}
for(i in seq_along(intervars)){
for(j in seq_along(intervars[[i]])){
if(length(intervars[[i]][[j]])>0){
print(j)
tdt = as.data.table(as.matrix(model_list_of_lists[[i]][[j]]$model.matrix))
iname = lapply(intervars[[i]][[j]],function(k)  k)
ivars = lapply(intervars[[i]][[j]],function(k)  c(unlist(str_split(k,':'))))
temp_vars = data.table(tdt[mu.u ==1,ivars[[1]],with = F],
tdt[mu.u ==0,ivars[[2]],with = F])
cols = unlist(ivars)
x1seq = seq(0.05,0.95,0.05)
x2seq = seq(0.05,0.95,0.05)
u_combos = expand.grid(apply(temp_vars[,ivars[[1]][1],with=F],2,quantile,x1seq),
apply(temp_vars[,ivars[[1]][2],with=F],2,quantile,x2seq))
names(u_combos) = ivars[[1]]
y_combos = expand.grid(apply(temp_vars[,ivars[[2]][1],with=F],2,quantile,x1seq),
apply(temp_vars[,ivars[[2]][2],with=F],2,quantile,x2seq))
names(y_combos) = ivars[[2]]
lcomb_data = data.table(u_combos,y_combos)
l1 = list(lcomb_data[[ivars[[1]][1]]])
names(l1) <- ivars[[1]][1]
lcu <- inla.make.lincombs(
'l1' = lcomb_data[[ivars[[1]][1]]],
"l2" = lcomb_data[[ivars[[1]][2]]],
"l3"  = lcomb_data[[ivars[[1]][1]]] * lcomb_data[[ivars[[1]][2]]])
for(n in seq_along(lcu)){
names(lcu[[n]][[1]]) <- ivars[[1]][1]
names(lcu[[n]][[2]]) <- ivars[[1]][2]
names(lcu[[n]][[3]]) <- iname[1]
}
lcy <- inla.make.lincombs(
'l1' = lcomb_data[[ivars[[2]][1]]],
"l2" = lcomb_data[[ivars[[2]][2]]],
"l3"  = lcomb_data[[ivars[[2]][1]]] * lcomb_data[[ivars[[2]][2]]])
for(n in seq_along(lcy)){
names(lcy[[n]][[1]]) <- ivars[[2]][1]
names(lcy[[n]][[2]]) <- ivars[[2]][2]
names(lcy[[n]][[3]]) <- iname[2]
}
names(lcu) = paste('u', 1:length(lcu), sep="")
names(lcy) = paste('y', 1:length(lcy), sep="")
lc = c(lcu, lcy)
u.sdres <- sd(model_list_of_lists[[i]][[j]]$.args$data$u,na.rm = T)#sd(y_like[is.finite(y_lik)])
y.sdres <- sd(model_list_of_lists[[i]][[j]]$.args$data$y/model_list_of_lists[[i]][[j]]$.args$data$u,na.rm=T)
pc.prec.u = list(prec = list(prior = "pc.prec", param = c(3*u.sdres, 0.01)))
pc.prec.y = list(prec = list(prior = "pc.prec", param = c(3*y.sdres, 0.01)))
# famcontrol = list(list(prior = "pcprec", param = c(3*u.sdres,0.01)),
#                  list(prior = "pcprec", param = c(3*y.sdres,0.01)))
newmodel = inla(formula = model_list_of_lists[[i]][[j]]$.args$formula ,control.compute = list(waic=TRUE,dic=TRUE),
c('poisson', 'binomial'),Ntrials = model_list_of_lists[[i]][[j]]$.args$Ntrials,
#control.inla= list(#strategy = "gaussian", int.strategy = "eb"),
#control.family = famcontrol,
control.fixed = list(expand.factor.strategy = "inla"),
data=model_list_of_lists[[i]][[j]]$.args$data,lincomb = lc,
control.update = list(result = model_list_of_lists[[i]][[j]]),
control.predictor=list(compute=TRUE),verbose=F)
lcd = newmodel$summary.lincomb
lcd$id = rownames(lcd)
lcd$group = str_extract(lcd$id,'^[u-y]')
lcd$group = ifelse(lcd$group== 'u','Project count','CE/total NEPA analyses')
lcd$group <- fct_rev(as.factor(lcd$group))
qvals = rbind(lcomb_data[,1:2],lcomb_data[,3:4],use.names = F)
names(qvals) <- c('scale_val1','scale_val2')
lcd$x1_quantile = unlist(replicate(2,rep(x1seq,nrow(lcd)/2/length(x1seq)),simplify = F))
lcd$x2_quantile = unlist(replicate(2,rep(x2seq,each = nrow(lcd)/2/length(x2seq)),simplify = F))
lcd = cbind(lcd,qvals)
axnames = unique(str_remove(names(temp_vars),'^[u-y]_'))
lcd[[axnames[[1]]]]<-lcomb_data[[names(temp_vars)[1]]]
lcd[[axnames[[2]]]]<-lcomb_data[[names(temp_vars)[2]]]
intername = gsub(':','x',str_remove_all(iname[[1]],'u_'))
figname = paste(mod_names[i],intername,sep='_')
lcd = data.table(lcd)
#lcd = lcd[!duplicated(paste(scale_val1,scale_val2,group)),]
lcd$i = i
lcd$j = j
lcd$DV <- mod_names[i]
empty_list = rbind(empty_list,lcd,fill = T,use.names = T)
}
}
}
model_list_of_lists[[1]]
summary(model_list_of_lists[[1]][[1]])
intervars
for(i in seq_along(intervars)){
print(i)
for(j in seq_along(intervars[[i]])){
if(length(intervars[[i]][[j]])>0){
print(j)
tdt = as.data.table(as.matrix(model_list_of_lists[[i]][[j]]$model.matrix))
iname = lapply(intervars[[i]][[j]],function(k)  k)
ivars = lapply(intervars[[i]][[j]],function(k)  c(unlist(str_split(k,':'))))
temp_vars = data.table(tdt[mu.u ==1,ivars[[1]],with = F],
tdt[mu.u ==0,ivars[[2]],with = F])
cols = unlist(ivars)
x1seq = seq(0.05,0.95,0.05)
x2seq = seq(0.05,0.95,0.05)
u_combos = expand.grid(apply(temp_vars[,ivars[[1]][1],with=F],2,quantile,x1seq),
apply(temp_vars[,ivars[[1]][2],with=F],2,quantile,x2seq))
names(u_combos) = ivars[[1]]
y_combos = expand.grid(apply(temp_vars[,ivars[[2]][1],with=F],2,quantile,x1seq),
apply(temp_vars[,ivars[[2]][2],with=F],2,quantile,x2seq))
names(y_combos) = ivars[[2]]
lcomb_data = data.table(u_combos,y_combos)
l1 = list(lcomb_data[[ivars[[1]][1]]])
names(l1) <- ivars[[1]][1]
lcu <- inla.make.lincombs(
'l1' = lcomb_data[[ivars[[1]][1]]],
"l2" = lcomb_data[[ivars[[1]][2]]],
"l3"  = lcomb_data[[ivars[[1]][1]]] * lcomb_data[[ivars[[1]][2]]])
for(n in seq_along(lcu)){
names(lcu[[n]][[1]]) <- ivars[[1]][1]
names(lcu[[n]][[2]]) <- ivars[[1]][2]
names(lcu[[n]][[3]]) <- iname[1]
}
lcy <- inla.make.lincombs(
'l1' = lcomb_data[[ivars[[2]][1]]],
"l2" = lcomb_data[[ivars[[2]][2]]],
"l3"  = lcomb_data[[ivars[[2]][1]]] * lcomb_data[[ivars[[2]][2]]])
for(n in seq_along(lcy)){
names(lcy[[n]][[1]]) <- ivars[[2]][1]
names(lcy[[n]][[2]]) <- ivars[[2]][2]
names(lcy[[n]][[3]]) <- iname[2]
}
names(lcu) = paste('u', 1:length(lcu), sep="")
names(lcy) = paste('y', 1:length(lcy), sep="")
lc = c(lcu, lcy)
u.sdres <- sd(model_list_of_lists[[i]][[j]]$.args$data$u,na.rm = T)#sd(y_like[is.finite(y_lik)])
y.sdres <- sd(model_list_of_lists[[i]][[j]]$.args$data$y/model_list_of_lists[[i]][[j]]$.args$data$u,na.rm=T)
pc.prec.u = list(prec = list(prior = "pc.prec", param = c(3*u.sdres, 0.01)))
pc.prec.y = list(prec = list(prior = "pc.prec", param = c(3*y.sdres, 0.01)))
# famcontrol = list(list(prior = "pcprec", param = c(3*u.sdres,0.01)),
#                  list(prior = "pcprec", param = c(3*y.sdres,0.01)))
newmodel = inla(formula = model_list_of_lists[[i]][[j]]$.args$formula ,control.compute = list(waic=TRUE,dic=TRUE),
c('poisson', 'binomial'),Ntrials = model_list_of_lists[[i]][[j]]$.args$Ntrials,
#control.inla= list(#strategy = "gaussian", int.strategy = "eb"),
#control.family = famcontrol,
control.fixed = list(expand.factor.strategy = "inla"),
data=model_list_of_lists[[i]][[j]]$.args$data,lincomb = lc,
control.update = list(result = model_list_of_lists[[i]][[j]]),
control.predictor=list(compute=TRUE),verbose=F)
lcd = newmodel$summary.lincomb
lcd$id = rownames(lcd)
lcd$group = str_extract(lcd$id,'^[u-y]')
lcd$group = ifelse(lcd$group== 'u','Project count','CE/total NEPA analyses')
lcd$group <- fct_rev(as.factor(lcd$group))
qvals = rbind(lcomb_data[,1:2],lcomb_data[,3:4],use.names = F)
names(qvals) <- c('scale_val1','scale_val2')
lcd$x1_quantile = unlist(replicate(2,rep(x1seq,nrow(lcd)/2/length(x1seq)),simplify = F))
lcd$x2_quantile = unlist(replicate(2,rep(x2seq,each = nrow(lcd)/2/length(x2seq)),simplify = F))
lcd = cbind(lcd,qvals)
axnames = unique(str_remove(names(temp_vars),'^[u-y]_'))
lcd[[axnames[[1]]]]<-lcomb_data[[names(temp_vars)[1]]]
lcd[[axnames[[2]]]]<-lcomb_data[[names(temp_vars)[2]]]
intername = gsub(':','x',str_remove_all(iname[[1]],'u_'))
figname = paste(mod_names[i],intername,sep='_')
lcd = data.table(lcd)
#lcd = lcd[!duplicated(paste(scale_val1,scale_val2,group)),]
lcd$i = i
lcd$j = j
lcd$DV <- mod_names[i]
empty_list = rbind(empty_list,lcd,fill = T,use.names = T)
}
}
}
intervars
i = 1; j = 1
tdt = as.data.table(as.matrix(model_list_of_lists[[i]][[j]]$model.matrix))
iname = lapply(intervars[[i]][[j]],function(k)  k)
ivars = lapply(intervars[[i]][[j]],function(k)  c(unlist(str_split(k,':'))))
temp_vars = data.table(tdt[mu.u ==1,ivars[[1]],with = F],
tdt[mu.u ==0,ivars[[2]],with = F])
ivars
intervars[[i]][[j]]
i = 2; j = 1
tdt = as.data.table(as.matrix(model_list_of_lists[[i]][[j]]$model.matrix))
iname = lapply(intervars[[i]][[j]],function(k)  k)
iname
tdt
intervars[[i]][[j]]
i = 2; j = 1
intervars[[i]][[j]]
intervars
intervars[[1]]
i = 2; j = 2
i = 1; j = 2
tdt = as.data.table(as.matrix(model_list_of_lists[[i]][[j]]$model.matrix))
tdt
iname = lapply(intervars[[i]][[j]],function(k)  k)
iname
ivars = lapply(intervars[[i]][[j]],function(k)  c(unlist(str_split(k,':'))))
temp_vars = data.table(tdt[mu.u ==1,ivars[[1]],with = F],
tdt[mu.u ==0,ivars[[2]],with = F])
cols = unlist(ivars)
x1seq = seq(0.05,0.95,0.05)
x2seq = seq(0.05,0.95,0.05)
u_combos = expand.grid(apply(temp_vars[,ivars[[1]][1],with=F],2,quantile,x1seq),
apply(temp_vars[,ivars[[1]][2],with=F],2,quantile,x2seq))
names(u_combos) = ivars[[1]]
y_combos = expand.grid(apply(temp_vars[,ivars[[2]][1],with=F],2,quantile,x1seq),
apply(temp_vars[,ivars[[2]][2],with=F],2,quantile,x2seq))
names(y_combos) = ivars[[2]]
lcomb_data = data.table(u_combos,y_combos)
u_combos
y_combos
l1 = list(lcomb_data[[ivars[[1]][1]]])
names(l1) <- ivars[[1]][1]
lcu <- inla.make.lincombs(
'l1' = lcomb_data[[ivars[[1]][1]]],
"l2" = lcomb_data[[ivars[[1]][2]]],
"l3"  = lcomb_data[[ivars[[1]][1]]] * lcomb_data[[ivars[[1]][2]]])
for(n in seq_along(lcu)){
names(lcu[[n]][[1]]) <- ivars[[1]][1]
names(lcu[[n]][[2]]) <- ivars[[1]][2]
names(lcu[[n]][[3]]) <- iname[1]
}
lcy <- inla.make.lincombs(
'l1' = lcomb_data[[ivars[[2]][1]]],
"l2" = lcomb_data[[ivars[[2]][2]]],
"l3"  = lcomb_data[[ivars[[2]][1]]] * lcomb_data[[ivars[[2]][2]]])
for(n in seq_along(lcy)){
names(lcy[[n]][[1]]) <- ivars[[2]][1]
names(lcy[[n]][[2]]) <- ivars[[2]][2]
names(lcy[[n]][[3]]) <- iname[2]
}
names(lcu) = paste('u', 1:length(lcu), sep="")
names(lcy) = paste('y', 1:length(lcy), sep="")
lc = c(lcu, lcy)
u.sdres <- sd(model_list_of_lists[[i]][[j]]$.args$data$u,na.rm = T)#sd(y_like[is.finite(y_lik)])
y.sdres <- sd(model_list_of_lists[[i]][[j]]$.args$data$y/model_list_of_lists[[i]][[j]]$.args$data$u,na.rm=T)
pc.prec.u = list(prec = list(prior = "pc.prec", param = c(3*u.sdres, 0.01)))
pc.prec.y = list(prec = list(prior = "pc.prec", param = c(3*y.sdres, 0.01)))
newmodel = inla(formula = model_list_of_lists[[i]][[j]]$.args$formula ,control.compute = list(waic=TRUE,dic=TRUE),
c('poisson', 'binomial'),Ntrials = model_list_of_lists[[i]][[j]]$.args$Ntrials,
#control.inla= list(#strategy = "gaussian", int.strategy = "eb"),
#control.family = famcontrol,
control.fixed = list(expand.factor.strategy = "inla"),
data=model_list_of_lists[[i]][[j]]$.args$data,lincomb = lc,
control.update = list(result = model_list_of_lists[[i]][[j]]),
control.predictor=list(compute=TRUE),verbose=F)
lcd = newmodel$summary.lincomb
lcd$id = rownames(lcd)
lcd$group = str_extract(lcd$id,'^[u-y]')
lcd$group = ifelse(lcd$group== 'u','Project count','CE/total NEPA analyses')
lcd$group <- fct_rev(as.factor(lcd$group))
qvals = rbind(lcomb_data[,1:2],lcomb_data[,3:4],use.names = F)
names(qvals) <- c('scale_val1','scale_val2')
lcd$x1_quantile = unlist(replicate(2,rep(x1seq,nrow(lcd)/2/length(x1seq)),simplify = F))
lcd$x2_quantile = unlist(replicate(2,rep(x2seq,each = nrow(lcd)/2/length(x2seq)),simplify = F))
lcd = cbind(lcd,qvals)
lcd
qvals
newmodel$summary.lincomb
newmodel$summary.lincomb.derived
#modnames = str_remove(str_remove(str_extract(model_sets,'models_[A-Z-a-z_]+'),'models_Type_Purpose'),'models_Type_')
mod_names = gsub('\\.RDS','',str_remove(model_sets,'models_Type_Purpose_'))
allvars = lapply(model_list_of_lists,function(x) sapply(x,function(y) y$model.matrix@Dimnames[[2]]))
intervars = lapply(allvars,function(x) lapply(x,function(y) grep(':',y,value=T)))
for(i in seq_along(intervars)){
for(j in seq_along(intervars[[i]])){
if(length(intervars[[i]][[j]])>0){
print(j)
i = 1; j = 2
tdt = as.data.table(as.matrix(model_list_of_lists[[i]][[j]]$model.matrix))
iname = lapply(intervars[[i]][[j]],function(k)  k)
ivars = lapply(intervars[[i]][[j]],function(k)  c(unlist(str_split(k,':'))))
temp_vars = data.table(tdt[mu.u ==1,ivars[[1]],with = F],
tdt[mu.u ==0,ivars[[2]],with = F])
cols = unlist(ivars)
x1seq = seq(0.05,0.95,0.05)
x2seq = seq(0.05,0.95,0.05)
u_combos = expand.grid(apply(temp_vars[,ivars[[1]][1],with=F],2,quantile,x1seq),
apply(temp_vars[,ivars[[1]][2],with=F],2,quantile,x2seq))
names(u_combos) = ivars[[1]]
y_combos = expand.grid(apply(temp_vars[,ivars[[2]][1],with=F],2,quantile,x1seq),
apply(temp_vars[,ivars[[2]][2],with=F],2,quantile,x2seq))
names(y_combos) = ivars[[2]]
lcomb_data = data.table(u_combos,y_combos)
l1 = list(lcomb_data[[ivars[[1]][1]]])
names(l1) <- ivars[[1]][1]
lcu <- inla.make.lincombs(
'l1' = lcomb_data[[ivars[[1]][1]]],
"l2" = lcomb_data[[ivars[[1]][2]]],
"l3"  = lcomb_data[[ivars[[1]][1]]] * lcomb_data[[ivars[[1]][2]]])
for(n in seq_along(lcu)){
names(lcu[[n]][[1]]) <- ivars[[1]][1]
names(lcu[[n]][[2]]) <- ivars[[1]][2]
names(lcu[[n]][[3]]) <- iname[1]
}
lcy <- inla.make.lincombs(
'l1' = lcomb_data[[ivars[[2]][1]]],
"l2" = lcomb_data[[ivars[[2]][2]]],
"l3"  = lcomb_data[[ivars[[2]][1]]] * lcomb_data[[ivars[[2]][2]]])
for(n in seq_along(lcy)){
names(lcy[[n]][[1]]) <- ivars[[2]][1]
names(lcy[[n]][[2]]) <- ivars[[2]][2]
names(lcy[[n]][[3]]) <- iname[2]
}
names(lcu) = paste('u', 1:length(lcu), sep="")
names(lcy) = paste('y', 1:length(lcy), sep="")
lc = c(lcu, lcy)
u.sdres <- sd(model_list_of_lists[[i]][[j]]$.args$data$u,na.rm = T)#sd(y_like[is.finite(y_lik)])
y.sdres <- sd(model_list_of_lists[[i]][[j]]$.args$data$y/model_list_of_lists[[i]][[j]]$.args$data$u,na.rm=T)
pc.prec.u = list(prec = list(prior = "pc.prec", param = c(3*u.sdres, 0.01)))
pc.prec.y = list(prec = list(prior = "pc.prec", param = c(3*y.sdres, 0.01)))
# famcontrol = list(list(prior = "pcprec", param = c(3*u.sdres,0.01)),
#                  list(prior = "pcprec", param = c(3*y.sdres,0.01)))
newmodel = inla(formula = model_list_of_lists[[i]][[j]]$.args$formula ,control.compute = list(waic=TRUE,dic=TRUE),
c('poisson', 'binomial'),Ntrials = model_list_of_lists[[i]][[j]]$.args$Ntrials,
#control.inla= list(#strategy = "gaussian", int.strategy = "eb"),
#control.family = famcontrol,
control.fixed = list(expand.factor.strategy = "inla"),
data=model_list_of_lists[[i]][[j]]$.args$data,lincomb = lc,
control.update = list(result = model_list_of_lists[[i]][[j]]),
control.predictor=list(compute=TRUE),verbose=F)
lcd = newmodel$summary.lincomb.derived
lcd$id = rownames(lcd)
lcd$group = str_extract(lcd$id,'^[u-y]')
lcd$group = ifelse(lcd$group== 'u','Project count','CE/total NEPA analyses')
lcd$group <- fct_rev(as.factor(lcd$group))
qvals = rbind(lcomb_data[,1:2],lcomb_data[,3:4],use.names = F)
names(qvals) <- c('scale_val1','scale_val2')
lcd$x1_quantile = unlist(replicate(2,rep(x1seq,nrow(lcd)/2/length(x1seq)),simplify = F))
lcd$x2_quantile = unlist(replicate(2,rep(x2seq,each = nrow(lcd)/2/length(x2seq)),simplify = F))
lcd = cbind(lcd,qvals)
axnames = unique(str_remove(names(temp_vars),'^[u-y]_'))
lcd[[axnames[[1]]]]<-lcomb_data[[names(temp_vars)[1]]]
lcd[[axnames[[2]]]]<-lcomb_data[[names(temp_vars)[2]]]
intername = gsub(':','x',str_remove_all(iname[[1]],'u_'))
figname = paste(mod_names[i],intername,sep='_')
lcd = data.table(lcd)
#lcd = lcd[!duplicated(paste(scale_val1,scale_val2,group)),]
lcd$i = i
lcd$j = j
lcd$DV <- mod_names[i]
empty_list = rbind(empty_list,lcd,fill = T,use.names = T)
}
}
}
fwrite(empty_list,'output/policypolitics/interaction_results.csv')
empty_list = fread('output/policypolitics/interaction_results.csv')
#qvals = c('0.05','0.25','0.5','0.75','0.95')
qvals_LCV = c('0.05','0.95')
qval_labels_lcv = c('~0','~95')
qvals_demVS = c('0.05','0.95')
qval_labels_dmVS = c('15%','65%')
qvals_Dem = c(0.05,0.90)
qval_labels_DEM = c('Republican','Democrat')
ext_dt = empty_list[DV=='Extractive',]
ext_dt$sig = ifelse(ext_dt$`0.025quant`<0&ext_dt$`0.975quant`>0,0,1)
ext_dt_lcv = ext_dt[!is.na(LCV_annual)& x2_quantile %in% qvals_LCV,]
ext_dt_dem = ext_dt[!is.na(percentD_H)&x2_quantile %in% qvals_demVS,]
ext_dt_rep = ext_dt[!is.na(democrat)&x2_quantile %in% qvals_Dem,]
ext_dt_dem
empty_list
tdt
lcd
for(i in seq_along(intervars)){
for(j in seq_along(intervars[[i]])){
if(length(intervars[[i]][[j]])>0){
print(j)
tdt = as.data.table(as.matrix(model_list_of_lists[[i]][[j]]$model.matrix))
iname = lapply(intervars[[i]][[j]],function(k)  k)
ivars = lapply(intervars[[i]][[j]],function(k)  c(unlist(str_split(k,':'))))
temp_vars = data.table(tdt[mu.u ==1,ivars[[1]],with = F],
tdt[mu.u ==0,ivars[[2]],with = F])
cols = unlist(ivars)
x1seq = seq(0.05,0.95,0.05)
x2seq = seq(0.05,0.95,0.05)
u_combos = expand.grid(apply(temp_vars[,ivars[[1]][1],with=F],2,quantile,x1seq),
apply(temp_vars[,ivars[[1]][2],with=F],2,quantile,x2seq))
names(u_combos) = ivars[[1]]
y_combos = expand.grid(apply(temp_vars[,ivars[[2]][1],with=F],2,quantile,x1seq),
apply(temp_vars[,ivars[[2]][2],with=F],2,quantile,x2seq))
names(y_combos) = ivars[[2]]
lcomb_data = data.table(u_combos,y_combos)
l1 = list(lcomb_data[[ivars[[1]][1]]])
names(l1) <- ivars[[1]][1]
lcu <- inla.make.lincombs(
'l1' = lcomb_data[[ivars[[1]][1]]],
"l2" = lcomb_data[[ivars[[1]][2]]],
"l3"  = lcomb_data[[ivars[[1]][1]]] * lcomb_data[[ivars[[1]][2]]])
for(n in seq_along(lcu)){
names(lcu[[n]][[1]]) <- ivars[[1]][1]
names(lcu[[n]][[2]]) <- ivars[[1]][2]
names(lcu[[n]][[3]]) <- iname[1]
}
lcy <- inla.make.lincombs(
'l1' = lcomb_data[[ivars[[2]][1]]],
"l2" = lcomb_data[[ivars[[2]][2]]],
"l3"  = lcomb_data[[ivars[[2]][1]]] * lcomb_data[[ivars[[2]][2]]])
for(n in seq_along(lcy)){
names(lcy[[n]][[1]]) <- ivars[[2]][1]
names(lcy[[n]][[2]]) <- ivars[[2]][2]
names(lcy[[n]][[3]]) <- iname[2]
}
names(lcu) = paste('u', 1:length(lcu), sep="")
names(lcy) = paste('y', 1:length(lcy), sep="")
lc = c(lcu, lcy)
u.sdres <- sd(model_list_of_lists[[i]][[j]]$.args$data$u,na.rm = T)#sd(y_like[is.finite(y_lik)])
y.sdres <- sd(model_list_of_lists[[i]][[j]]$.args$data$y/model_list_of_lists[[i]][[j]]$.args$data$u,na.rm=T)
pc.prec.u = list(prec = list(prior = "pc.prec", param = c(3*u.sdres, 0.01)))
pc.prec.y = list(prec = list(prior = "pc.prec", param = c(3*y.sdres, 0.01)))
# famcontrol = list(list(prior = "pcprec", param = c(3*u.sdres,0.01)),
#                  list(prior = "pcprec", param = c(3*y.sdres,0.01)))
newmodel = inla(formula = model_list_of_lists[[i]][[j]]$.args$formula ,control.compute = list(waic=TRUE,dic=TRUE),
c('poisson', 'binomial'),Ntrials = model_list_of_lists[[i]][[j]]$.args$Ntrials,
#control.inla= list(#strategy = "gaussian", int.strategy = "eb"),
#control.family = famcontrol,
control.fixed = list(expand.factor.strategy = "inla"),
data=model_list_of_lists[[i]][[j]]$.args$data,lincomb = lc,
control.update = list(result = model_list_of_lists[[i]][[j]]),
control.predictor=list(compute=TRUE),verbose=F)
lcd = newmodel$summary.lincomb.derived
lcd$id = rownames(lcd)
lcd$group = str_extract(lcd$id,'^[u-y]')
lcd$group = ifelse(lcd$group== 'u','Project count','CE/total NEPA analyses')
lcd$group <- fct_rev(as.factor(lcd$group))
qvals = rbind(lcomb_data[,1:2],lcomb_data[,3:4],use.names = F)
names(qvals) <- c('scale_val1','scale_val2')
lcd$x1_quantile = unlist(replicate(2,rep(x1seq,nrow(lcd)/2/length(x1seq)),simplify = F))
lcd$x2_quantile = unlist(replicate(2,rep(x2seq,each = nrow(lcd)/2/length(x2seq)),simplify = F))
lcd = cbind(lcd,qvals)
axnames = unique(str_remove(names(temp_vars),'^[u-y]_'))
lcd[[axnames[[1]]]]<-lcomb_data[[names(temp_vars)[1]]]
lcd[[axnames[[2]]]]<-lcomb_data[[names(temp_vars)[2]]]
intername = gsub(':','x',str_remove_all(iname[[1]],'u_'))
figname = paste(mod_names[i],intername,sep='_')
lcd = data.table(lcd)
#lcd = lcd[!duplicated(paste(scale_val1,scale_val2,group)),]
lcd$i = i
lcd$j = j
lcd$DV <- mod_names[i]
empty_list = rbind(empty_list,lcd,fill = T,use.names = T)
}
}
}
fwrite(empty_list,'output/policypolitics/interaction_results.csv')
bt = readRDS('scratch/boilerplate/big_text_files/big_eis_text.rds')
setwd('~/Documents/GitHub/tuolumne/')
bt = readRDS('scratch/boilerplate/big_text_files/big_eis_text.rds')
cc = grepl('climate change',bt$text,perl = T)
which(cc)
bt[40804,]
not_comment = !grepl('Response:|The comment states',cc)
not_comment = !grepl('Response:|The comment states',bt$text,perl = T)
table(cc,not_comment)
which(cc & not_comment)
bt$text[48646]
bt[48646,]
require(lme4)
# Example from the 'glmer' function
gm1 <- glmer(cbind(incidence,size-incidence)~period+(1|herd),
family="binomial",data=cbpp)
overdisp.glmer(gm1)
install.packages('lme4')
require(lme4)
# Example from the 'glmer' function
gm1 <- glmer(cbind(incidence,size-incidence)~period+(1|herd),
family="binomial",data=cbpp)
overdisp.glmer(gm1)
install.packages('RVAideMemoire')
require('RVAideMemoire')
# Example from the 'glmer' function
gm1 <- glmer(cbind(incidence,size-incidence)~period+(1|herd),
family="binomial",data=cbpp)
overdisp.glmer(gm1)
test = fread('~/Box/coastal_flooding/output/flood_tweets_by_city_hour/flood_tweets_by_city_hour_2018.csv')
require(data.table)
test = fread('~/Box/coastal_flooding/output/flood_tweets_by_city_hour/flood_tweets_by_city_hour_2018.csv')
head(test)
test = fread('~/Box/coastal_flooding/output/coastal_city_by_day/2015_03_27.csv')
head(test)
tt = test[Probability_Flooding_V2>0.5,]
tt
tt$text[1:10]
tt$text[11:20]
tt = test[Probability_Flooding_V2>0.8,]
tt$text[11:20]
tt$text[21:30]
tt[order(-Probability_Flooding_V2),][1:20,]
tt[order(-Probability_Flooding_V2),][1:20,][4,]
tt[order(-Probability_Flooding_V2),][1:20,]
